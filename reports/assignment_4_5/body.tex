\textit{This brief report explains how we constructed the intermediate representation for the $\mu$C programming language and generated the concluding LLVM-assembler.}

\section{Intermediate Representation}

%TODO How is our IR represented? Structure etc.
Our intermediate representation (IR) is essentially a flattened out version of our abstract syntax tree (AST).
All nodes in the original AST have been converted into ordered flat instructions that can later be directly translated into LLVM instructions. Thus our IR is very similar to that of LLVM.

%TODO How is the IR generated?
The IR is generated by calling "generate\_ir" on the root node of the AST. This method takes a list as one of its arguments, which is the list that all IR instructions are then appended to by the consecutive walk down the AST. All nodes know how to append themselves to this list, but before they do they have to call "generate\_ir" on their children to ensure that they are evaluated before themselves to ensure correct order of the instructions.

%TODO Describe a simple IR-tree. Tikz picture?
As an example, we take the example $\mu$C-code in listing \ref{lst:example_c} and generate the IR for it. The generated IR is then similar (not verbatim copy) to listing \ref{lst:example_ir}.

\lstinputlisting[float, label=lst:example_c, caption={
  Example program in $\mu$C.
}]{example.c}

\lstinputlisting[float, label=lst:example_ir, caption={
  Example program in listing \ref{lst:example_c} converted to a simplified version of our IR.
}]{example.ir}

As can be seen in listing \ref{lst:example_ir}, we have a global variable with the name "i" and the type "i32", then we have a function named "main". The function in our IR has five parameters, the first being the name of the function, the second represents the type, the third is a list of formals, the fourth is a list of local declarations in the function, and the fifth and last one is a list of all statements in the function.

The statement list contains two statements, the first being an Eval instruction that takes an identifier as first argument and an expression as second argument. The identifier refers to the global variable "i", and the expression is simply a constant i32 value, namely $1$.

The second statement is a return instruction, which takes an expression or identifier as argument. Here we return the value of the identifier "i".

\section{Code Generation}

%TODO How is the LLVM code generated out of the IR structure?
After the IR has been constructed, converting this to proper LLVM-code is very straightforward. Because our IR is so close to LLVM already each instruction can be translated straight to LLVM-code without any further pre-processing.

%TODO  - Walking down the IR-tree etc.
Generating the LLVM-code is similar to generating the IR. Iterate over the IR-list constructed from the AST and call "generate\_llvm" on each entry. Each call to this method returns a string that represents the LLVM-code for that particular instruction. Then concatenate all strings together to form the complete program.

\subsection{LLVM Structure}

%TODO What is the general layout of LLVM code?
The structure of the LLVM assembly language is very close to ordinary assembly with the exception of some high-level functionality such as strict typing and functions.

%TODO How does it compare to assembler such as MIPS?
%TODO What are the benefits of using LLVM instead of MIPS?

\subsection{Control Flow Statements}

%TODO How do we handle if-statements?
%TODO How do we handle while-statements?
%TODO What is the structure of these in IR and LLVM?
%TODO Basic blocks?

\subsection{Variable References}

%TODO Stack allocations
%TODO Global allocations
%TODO Arrays?
%TODO How are arrays passed in function calls?
%TODO How do we access regular allocations, store, load etc.
%TODO How do we access array-elements? store load etc
%TODO Temporaries and their counters

\section{Design Decisions}

%TODO Our solution to putint, putstring etc. Where we include a header in the LLVM code if needed.
%TODO How do we handle the creation of new basic blocks in LLVM after a return?

% - Semi-decisions, should we really describe these in this section?
%TODO How do we flatten arithmetic expressions? Are there any design decisions there?
%TODO How do we handle references to global variables inside functions? How do we determine if it is referencing a local or global?

\section{Usage}
%TODO How do you use the compiler?
%TODO What are the generated output files?
%TODO How do you execute the generated .ll files?
%TODO How do you generate a binary out of the .ll files?

\section{Conclusions}
